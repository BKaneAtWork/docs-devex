= Query Concepts
:description: An overview of common concepts to use the Query service.
:page-topic-type: concept
:keywords: n1ql, sqlpp, query, result, parameter, prepared, prepared statement, consistent, consistency

[abstract]
{description}

== Queries

An {sqlpp} query is a string parsed by the query service.
The {sqlpp} query language is based on SQL, but designed for structured and flexible JSON documents.

* You can have nested sub-queries. {sqlpp} queries run on JSON documents
* You can run a query over multiple documents by using the `JOIN` clause
* Data in {sqlpp} can be nested. You can navigate through nested arrays using operators and functions. 
* Data can be irregular. You can specify conditions in the `WHERE` clause to retrieve data
* You can transform the results using standard `GROUP BY`, `ORDER BY`, `LIMIT`, and `OFFSET` clauses as well as a rich set of functions.

== Results

Capella returns query results for each query as a set of JSON documents. The returned document set can be uniform or non-uniform. 

* A `SELECT` statement that specifies a fixed set of attribute (column) names results in a uniform set of documents.

* A `SELECT` statement that specifies the wild card (*) results in a non-uniform result set. 

Every returned document meets the query criteria.

Here's a sample query and the result returned:

.Query
[source,sqlpp]
----
SELECT name, brewery_id from `beer-sample` WHERE brewery_id IS NOT MISSING LIMIT 2;
----

.Result
[source,json]
----
{
    "requestID": "fbea9e79-a2e2-4ab8-9fdc-14e098838cc1",
    "signature": {
        "brewery_id": "json",
        "name": "json"
    },
    "results": [
        {
            "brewery_id": "big_horn_brewing_the_ram_2",
            "name": "Schaumbergfest"
        },
        {
            "brewery_id": "ballast_point_brewing",
            "name": "Wahoo Wheat Beer"
        }
    ],
    "status": "success",
    "metrics": {
        "elapsedTime": "131.492184ms",
        "executionTime": "131.261322ms",
        "resultCount": 2,
        "resultSize": 205
    }
}
----


[#data-hierarchy]
== Data Hierarchy

Couchbase organizes its data using a hierarchy. This hierarchy is important to know when creating paths to your data for queries.   [need to expand this]

* Datastores
** Namespaces(?)
*** Buckets
**** Scopes
***** Collections
****** Documents

[#keyspaces]
== Keyspaces

A keyspace is a location that contains documents with data that you can query.

Couchbase stores documents within a <<data-hierarchy,logical hierarchy>> of buckets, scopes, and collections. This enables separation between documents of different types.

To query your data, you need to identify the [.term]_paths_ to get to the keyspace (where the data is stored) using a keyspace reference.

In addition to querying your data, you can also query the system keyspaces that make up the system, (datastores, namespaces, buckets, scopes, collections, indexes, and dual). Querying system keyspaces provides various monitoring details and statistics about individual queries and the Query service. For information on how to query system keyspaces, see xref: [Monitor Queries]. 



[#keyspace-reference]
== Keyspace References

A keyspace reference directs the Query service to the data you want to query. For most queries, you must provide one or more keyspace references to specify where the Query service should get the data to run the query.

A keyspace reference may be 

* a _full_ keyspace reference: a path comprising the bucket, the scope, and the collection which contains the documents you want. 
+
For example, `default:{backtick}travel-sample{backtick}.inventory.airline` refers to documents in:

** `travel-sample` bucket
*** `inventory` scope
**** `airline` collection 

* a _partial_ keyspace reference that only uses the collection name. 
+ 
To use only the collection name, you must set the <<query-context,query context>> to specify a bucket and scope before running a query. 
+
Couchbase uses the  bucket and scope supplied by the query context to resolve the partial keyspace reference.

For compatibility with legacy versions of Couchbase Server, the name of the scope and collection may be omitted when referring to the default collection in the default scope within a bucket.

For example, you can refer to the travel-sample keyspace, if it is in the default collection in the default scope in the travel-sample bucket. In this case, the <<query-context,query context>> must not be set.


[#query-context]
== Query Context

The [def]_query context_ specifies the namespace, bucket, and scope used to resolve partial keyspace references.

When the query context is set, you can refer to a collection using just the collection name, without having to enter the keyspace path.

When the query context is not set, it defaults to the `default` namespace, with no bucket, scope, or collection.

* To set the query context in the Query Tab, from xref:tools:query-workbench.adoc#query-context[query context] choose a bucket and scope from the lists.

* To set the query context from the cbq shell or the REST API, use the xref:settings:query-settings.adoc#query_context[query_context] request-level parameter.

.Tenant separation
[IMPORTANT]
--
By using queries with partial keyspace references, which are resolved using the query context, a database application can be switched from one scope to another simply by changing the query context.
This can be used to support the separation of tenant data in a multi-tenancy environment.
--

[#paths]
== Paths

[.term]_Paths_ provide a method for finding data in document structures without having to retrieve the entire document or handle it within an application. Only returning relevant information to an application reduces querying bandwidth.

JSON supports a nested structure, allowing documents to contain other documents, also known as sub-documents. SQL++ uses paths to support nested data. 

Paths use dot notation syntax to identify the logical location of an attribute within a document.
For example, to get the street from a customer order, use the path `orders.billTo.street`.
This path refers to the value for `street` in the `billTo` object.
A path is used with arrays or nested objects to get to attributes within the data structure.

Array syntax in the path can also be used to get to information.
For example, the path `orders.items[0].productId` evaluates to the `productId` value for the first array element under the order item, `items`.

See xref:n1ql-language-reference/index.adoc#nested-path-expressions[Nested Path Expressions] for more details.

[#named-placeholders]
== Parameterized Queries

Use placeholders to declare dynamic query parameters in {sqlpp}. You can construct a query with arguments to be used as the placeholder value in the query.

There are three types of placeholders.

[%header,cols="30%,20%,50%"]
|===
| Placeholder ^| Form | Use 

| numbered positional placeholder
^|$1
| In the query, $1 refers to the first argument,$2 to the second, and so on.


| unnumbered positional parameter
^|?
| The first occurrence of ? refers to the first argument, the second occurrence of ? to the second, and so on.


| Named placeholders
^|$name
| Useful when there are many query parameters and ensuring that they are all in the correct order is cumbersome.

|===

Set query parameter values when you run the query, using the cbq query shell, the Query Tab, or the {sqlpp} REST API.

For more information and examples, refer to xref:settings:query-settings.adoc#section_srh_tlm_n1b[Named Parameters and Positional Parameters].

[#prepare-stmts]
== Query Optimization Using Prepared Statements

When a {sqlpp} query string is sent to the server, the server inspects the string and parses it, to plan which indexes to query.
Once this is done, it generates a _query plan_.
The computation for the plan adds some additional processing time and overhead for the query.

You can prepare a frequently-used query so that its plan is generated only once. Subsequent queries using the same query string will use the pre-generated plan, reducing processing resources.

NOTE: Parameterized queries are considered the same query for caching and planning purposes, even if the supplied parameters are different.

For more information on how to optimize queries using prepared statements, refer to xref:guides:prep-statements.adoc[Use Prepared Statements] and  xref:n1ql:n1ql-language-reference/prepare.adoc[PREPARE] statement.

== Indexes

Indexes help improve the performance of a query. Indexes allow specific data (for example, specific document properties) to be retrieved quickly and to distribute load away from data nodes in MDS topologies.

In order to make a keyspace queryable, it must have at least one index defined.

* You can define a _primary index_ on a keyspace.
Primary indexes are based on the unique key of every item in a specified collection. A primary index is intended to be used for simple queries, which have no filters or predicates.

* You can also create a _secondary index_ on specific fields in a keyspace.
Secondary indexes, often referred to as Global Secondary Indexes or GSIs, constitute the principal means of indexing documents to be accessed by the Query Service.
+
For example, creating a secondary index on the `name` and `email` fields in the `users` keyspace would allow you to query the keyspace regarding a document's `name` or `email` properties.

When an index includes the actual values of all the fields specified in the query, the index covers the query and eliminates the need to fetch the actual values from the Data Service.
This type of index is called a covering index and the query is a covered query.

For more information, refer to xref:learn:services-and-indexes/indexes/global-secondary-indexes.adoc[Indexes].

== Index Building

Index creation happens in two phases: the [def]_creation phase_ and the [def]_build phase_.
During the creation phase, the Index Service validates the user input, decides the host node for the index, and creates the index metadata on the host node.
During the build phase, the Index Service reads the documents from the Data Service and builds the index.
The build phase cannot start until the creation phase is complete.

Creating and building indexes can take a long time on keyspaces with lots of existing documents.
When you create an index, you can choose to _defer_ the build phase, and then build the deferred index later.
This allows multiple indexes to be built at once rather than having to re-scan the entire keyspace for each index.

For more information and examples, refer to xref:n1ql:n1ql-language-reference/createprimaryindex.adoc[CREATE PRIMARY INDEX], xref:n1ql:n1ql-language-reference/createindex.adoc[CREATE INDEX], and xref:n1ql:n1ql-language-reference/build-index.adoc[BUILD INDEX].

== Index Consistency

(((consistent)))
(((consistency)))
Because indexes are by design outside the data service, they are eventually consistent with respect to changes to documents and, depending on how you issue the query, may at times not contain the most up-to-date information.
This may especially be the case when deployed in a write-heavy environment: changes may take some time to propagate over to the index nodes.

The asynchronous updating nature of global secondary indexes means that they can be very quick to query and do not require the additional overhead of index recalculations at the time documents are modified.
{sqlpp} queries are forwarded to the relevant indexes and the queries are done based on indexed information, rather than the documents as they exist in the data service.

With default query options, the query service will rely on the current index state: the most up-to-date document versions are not retrieved, and only the indexed versions are queried.
This provides the best performance.
Only updates occurring with a small time frame may not yet have been indexed.

The query service can use the latest versions of documents by modifying the [.api]`consistency` of the query.
This is done by setting the [.api]`scan_consistency` parameter to [.api]`REQUEST_PLUS`.
When using this consistency mode, the query service will ensure that the indexes are synchronized with the data service before querying.
For more information, refer to xref:settings:query-settings.adoc#scan_consistency[Query Settings].
